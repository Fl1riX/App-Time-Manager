import psutil, sqlite3, logging, sys, time, threading, gui

from PyQt5.QtWidgets import QApplication, QDesktopWidget
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg
from matplotlib.figure import Figure
from datetime import datetime

logging.basicConfig(
    level=logging.INFO,
    filename="manager_logs.log",
    filemode="w",
    encoding="utf-8",
    format="%(asctime)s - %(levelname)s - %(message)s"
)
    
def get_all_time():
    data = {}
    try:
        with sqlite3.connect("data.db") as con:
            cur = con.cursor()
            
            cur.execute("""SELECT name, date, MAX(CAST(time AS INT)) FROM data GROUP BY name, date""")
            result = cur.fetchall()
            
        logging.info(f"üìä –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –≤—Ä–µ–º—è –∑–∞ –¥–µ–Ω—å: {result}")
        
        for name, _, max_time in result:
            data[name] = data.get(name, 0) + max_time

    except Exception as e:
        logging.error(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –¥–∞–Ω–Ω—ã—Ö: {e}")
        return 0

    return data
                 
def today_time(name):
    with sqlite3.connect("data.db") as con:
        cur = con.cursor()
        today = datetime.now().date() 
        cur.execute("SELECT MAX(CAST(time AS INT)) FROM data WHERE date=? and name=? ", (str(today), name,))

        result = cur.fetchone()
    
    return result

def get_tracked_apps():
    with sqlite3.connect("data.db") as con: 
        cur = con.cursor()
        cur.execute("""CREATE TABLE IF NOT EXISTS data (name TEXT, date TEXT, time INTEGER)""")
        con.commit()
        
        cur.execute("""SELECT name FROM data""")
        result = list(set(cur.fetchall()))
        
    return result
        
def tracking_loop():
    while True:
        for i in get_tracked_apps():
            main(i[0])
            time.sleep(300) 

def main(name):
    try:
        min_time_list = []

        logging.info(f"üîç –ü–æ–∏—Å–∫ –ø—Ä–æ—Ü–µ—Å—Å–∞: {name}")

        # –ü–æ–∏—Å–∫ –ø—Ä–æ—Ü–µ—Å—Å–∞ –ø–æ –∏–º–µ–Ω–∏
        for p in psutil.process_iter(['name']):
            if p.info['name'] == name:
                # –ò–∑–≤–ª–µ—á–µ–Ω–∏–µ –≤—Ä–µ–º–µ–Ω–∏ —Å—Ç–∞—Ä—Ç–∞ –ø—Ä–æ—Ü–µ—Å—Å–∞
                start_time_str = str(p).split("started=")[1].split("'")[1]

                # –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –≤—Ä–µ–º–µ–Ω–∏ —Å—Ç–∞—Ä—Ç–∞ –≤ –º–∏–Ω—É—Ç—ã
                start_time = int(start_time_str.split(":")[0]) * 60 + int(start_time_str.split(":")[1])

                min_time_list.append(start_time)

        if not min_time_list:
            logging.warning(f"‚ö†Ô∏è –ü—Ä–æ—Ü–µ—Å—Å '{name}' –Ω–µ –Ω–∞–π–¥–µ–Ω.")
            gui.show_error(f"–ü—Ä–æ—Ü–µ—Å—Å '{name}' –Ω–µ –Ω–∞–π–¥–µ–Ω.")
            return

        start_time = min(min_time_list)
        logging.info(f"‚úÖ –ü—Ä–æ—Ü–µ—Å—Å '{name}' –Ω–∞–π–¥–µ–Ω. –í—Ä–µ–º—è —Å—Ç–∞—Ä—Ç–∞: {start_time} –º–∏–Ω—É—Ç –æ—Ç –Ω–∞—á–∞–ª–∞ —Å—É—Ç–æ–∫.")

        # –ü–æ–ª—É—á–µ–Ω–∏–µ —Ç–µ–∫—É—â–µ–≥–æ –≤—Ä–µ–º–µ–Ω–∏ –≤ –º–∏–Ω—É—Ç–∞—Ö
        now_time_sp = str(datetime.now()).split(" ")[1].split(":")
        now_time = int(now_time_sp[0]) * 60 + int(now_time_sp[1])

        # –ü–æ–¥—Å—á–µ—Ç –≤—Ä–µ–º–µ–Ω–∏ —Ä–∞–±–æ—Ç—ã –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è
        min_app_time = now_time - start_time

        try:
            with sqlite3.connect("data.db") as con:
                cur = con.cursor()

                time_str = f"{min_app_time} –º–∏–Ω"
                cur.execute("""SELECT * FROM data WHERE name=? AND date=?""", (name, datetime.now().date(),))
                record_exists = cur.fetchall()
                
                if record_exists:
                    cur.execute("""UPDATE data SET time=? WHERE name=? AND date=?""", (time_str, name, datetime.now().date()))
                else:
                    cur.execute("""INSERT INTO data (name, time, date) VALUES (?, ?, ?)""", (name, time_str, datetime.now().date()))
                    
                con.commit()

                logging.info(f"üíæ –î–∞–Ω–Ω—ã–µ –∑–∞–ø–∏—Å–∞–Ω—ã: {name}, {time_str}")

        except sqlite3.Error as e:
            logging.error(f"‚ùå –û—à–∏–±–∫–∞ SQLite: {e}")

    except psutil.NoSuchProcess:
        logging.error(f"‚ùå –ü—Ä–æ—Ü–µ—Å—Å '{name}' –Ω–µ –Ω–∞–π–¥–µ–Ω.")
        gui.show_error(f"–ü—Ä–æ—Ü–µ—Å—Å '{name}' –Ω–µ –Ω–∞–π–¥–µ–Ω.")
        
    except psutil.AccessDenied:
        logging.error(f"üö´ –ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ –ø—Ä–æ—Ü–µ—Å—Å—É '{name}'.")
        gui.show_error(f"–ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ –ø—Ä–æ—Ü–µ—Å—Å—É '{name}'.")

    except psutil.ZombieProcess:
        logging.error(f"‚ö∞Ô∏è –ü—Ä–æ—Ü–µ—Å—Å '{name}' —Å—Ç–∞–ª –∑–æ–º–±–∏.")
        gui.show_error(f"–ü—Ä–æ—Ü–µ—Å—Å '{name}' —Å—Ç–∞–ª –∑–æ–º–±–∏.")

    except Exception as e:
        logging.error(f"‚ùå –ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞: {e}")
        gui.show_error(f"–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞: {e}")
        
class AppTimeManager:   
    def __init__(self):
        self.app = QApplication(sys.argv)
        self.main_win = gui.MainWindow()
    
    def center(self):
        qr = self.frameGeometry()
        cp = QDesktopWidget().availableGeometry().center()
        qr.moveCenter(cp)
        self.move(qr.topLeft())
    
    def run(self):
        self.main_win.show()
        sys.exit(self.app.exec_())

if __name__ == "__main__":
    th = threading.Thread(target=tracking_loop, daemon=True)
    th.start()
    
    app_manager = AppTimeManager()
    app_manager.run()